// Generated by CoffeeScript 1.10.0
var AVAILABLE_NATIVE_MODULES, EventEmitter, NodeVM, VM, VMError, _compileToJS, _prepareContextify, cf, fs, pa, sb, ut, version, vm,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

version = process.versions.node.split('.');

if (parseInt(version[0]) === 0 && parseInt(version[1]) < 11) {
  throw new Error("vm2 requires Node.js version 0.11+ or io.js 1.0+ (current version: " + process.versions.node + ")");
}

fs = require('fs');

vm = require('vm');

pa = require('path');

ut = require('util');

EventEmitter = require('events').EventEmitter;

sb = fs.readFileSync(__dirname + "/sandbox.js", "utf8");

cf = fs.readFileSync(__dirname + "/contextify.js", "utf8");

AVAILABLE_NATIVE_MODULES = ['assert', 'buffer', 'child_process', 'constants', 'crypto', 'tls', 'dgram', 'dns', 'http', 'https', 'net', 'querystring', 'url', 'domain', 'events', 'fs', 'path', 'module', 'os', 'punycode', 'stream', 'string_decoder', 'timers', 'tty', 'util', 'sys', 'vm', 'zlib'];


/*
Prepare value for contextification.

@property {Object} value Value to prepare.
@return {Object} Prepared value.

@private
 */

_prepareContextify = function(value) {
  var desc, i, j, key, len, o, ref;
  if (typeof value === 'object') {
    if (value === null) {
      return value;
    }
    if (value instanceof String) {
      return String(value);
    }
    if (value instanceof Number) {
      return Number(value);
    }
    if (value instanceof Boolean) {
      return Boolean(value);
    }
    if (value instanceof Array) {
      return (function() {
        var j, len, results;
        results = [];
        for (j = 0, len = value.length; j < len; j++) {
          i = value[j];
          results.push(_prepareContextify(i));
        }
        return results;
      })();
    }
    if (value instanceof Error) {
      return value;
    }
    if (value instanceof Date) {
      return value;
    }
    if (value instanceof RegExp) {
      return value;
    }
    if (value instanceof Buffer) {
      return value;
    }
    o = {};
    ref = Object.getOwnPropertyNames(value);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      desc = Object.getOwnPropertyDescriptor(value, key);
      if (desc.value != null) {
        desc.value = _prepareContextify(desc.value);
      }
      Object.defineProperty(o, key, desc);
    }
    return o;
  } else {
    return value;
  }
};

_compileToJS = function(code, language) {
  switch (language) {
    case 'coffeescript':
    case 'coffee-script':
    case 'cs':
    case 'text/coffeescript':
      return require('coffee-script').compile(code, {
        header: false,
        bare: true
      });
    case 'javascript':
    case 'java-script':
    case 'js':
    case 'text/javascript':
      return code;
    default:
      throw new VMError("Unsupported language '" + language + "'.");
  }
};


/*
Class VM.

@property {Boolean} running True if VM was initialized.
@property {Object} options VM options.
@property {Object} context VM's context.
 */

VM = (function(superClass) {
  extend(VM, superClass);

  VM.prototype.running = false;

  VM.prototype.options = null;

  VM.prototype.context = null;


  /*
  	Create VM instance.
  	
  	@param {Object} [options] VM options.
  	@return {VM}
   */

  function VM(options) {
    var ref, ref1, ref2;
    if (options == null) {
      options = {};
    }
    this.options = {
      timeout: (ref = options.timeout) != null ? ref : void 0,
      sandbox: (ref1 = options.sandbox) != null ? ref1 : null,
      language: (ref2 = options.language) != null ? ref2 : 'javascript'
    };
  }


  /*
  	Run the code in VM.
  	
  	@param {String} code Code to run.
  	@return {*} Result of executed code.
   */

  VM.prototype.run = function(code) {
    'use strict';
    var contextify, name, ref, script, value;
    if (this.options.language !== 'javascript') {
      code = _compileToJS(code, this.options.language);
    }
    if (this.running) {
      script = new vm.Script(code, {
        filename: "vm",
        displayErrors: false
      });
      return script.runInContext(this.context, {
        filename: "vm",
        displayErrors: false,
        timeout: this.options.timeout
      });
    }
    this.context = vm.createContext();
    contextify = vm.runInContext("(function(require) { " + cf + " \n})", this.context, {
      filename: "contextify.js",
      displayErrors: false
    }).call(this.context, require);
    if (this.options.sandbox) {
      if (typeof this.options.sandbox !== 'object') {
        throw new VMError("Sandbox must be object");
      }
      ref = this.options.sandbox;
      for (name in ref) {
        value = ref[name];
        contextify(_prepareContextify(value), name);
      }
    }
    script = new vm.Script(code, {
      filename: "vm",
      displayErrors: false
    });
    this.running = true;
    return script.runInContext(this.context, {
      filename: "vm",
      displayErrors: false,
      timeout: this.options.timeout
    });
  };

  return VM;

})(EventEmitter);


/*
Class NodeVM.

@property {Object} cache Cache of loaded modules.
@property {Object} natives Cache of native modules.
@property {Object} module Pointer to main module.
@property {Function} proxy Proxy used by `call` method to securely call methods in VM.
 */

NodeVM = (function(superClass) {
  extend(NodeVM, superClass);

  NodeVM.prototype.cache = null;

  NodeVM.prototype.natives = null;

  NodeVM.prototype.module = null;

  NodeVM.prototype.proxy = null;


  /*
  	Create NodeVM instance.
  	
  	Unlike VM, NodeVM lets you use require same way like in regular node.
  	
  	@param {Object} [options] VM options.
  	@return {NodeVM}
   */

  function NodeVM(options) {
    var j, k, len, len1, mod, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
    if (options == null) {
      options = {};
    }
    this.natives = {};
    this.options = {
      sandbox: (ref = options.sandbox) != null ? ref : null,
      console: (ref1 = options.console) != null ? ref1 : 'inherit',
      require: (ref2 = options.require) != null ? ref2 : false,
      language: (ref3 = options.language) != null ? ref3 : 'javascript',
      requireExternal: (ref4 = options.requireExternal) != null ? ref4 : false,
      requireNative: {},
      requireRoot: (ref5 = options.requireRoot) != null ? ref5 : false,
      useStrict: (ref6 = options.useStrict) != null ? ref6 : true
    };
    if (options.requireNative) {
      if (Array.isArray(options.requireNative)) {
        ref7 = options.requireNative;
        for (j = 0, len = ref7.length; j < len; j++) {
          mod = ref7[j];
          if (indexOf.call(AVAILABLE_NATIVE_MODULES, mod) >= 0) {
            this.options.requireNative[mod] = true;
          }
        }
      }
    } else {
      for (k = 0, len1 = AVAILABLE_NATIVE_MODULES.length; k < len1; k++) {
        mod = AVAILABLE_NATIVE_MODULES[k];
        this.options.requireNative[mod] = true;
      }
    }
  }


  /*
  	Securely call method in VM. All arguments except functions are cloned during the process to prevent context leak. Functions are wrapped to secure closures. 
  	
  	Buffers are copied!
  	
  	IMPORTANT: Method doesn't check for circular objects! If you send circular structure as an argument, you process will stuck in infinite loop.
  	
  	@param {Function} method Method to execute.
  	@param {...*} argument Arguments.
  	@return {*} Return value of executed method.
   */

  NodeVM.prototype.call = function(method) {
    'use strict';
    if (!this.running) {
      throw new VMError("VM is not running");
    }
    if (typeof method === 'function') {
      return this.proxy.apply(this, arguments);
    } else {
      throw new VMError("Unrecognized method type");
    }
  };


  /*
  	Run the code in NodeVM. 
  	
  	First time you run this method, code is executed same way like in node's regular `require` - it's executed with `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.
  	
  	@param {String} code Code to run.
  	@param {String} [filename] Filename that shows up in any stack traces produced from this script.
  	@return {*} Result of executed code.
   */

  NodeVM.prototype.run = function(code, filename) {
    'use strict';
    var closure, contextify, dirname, name, parent, ref, ref1, script, value;
    if (global.isVM) {
      throw new VMError("You can't nest VMs");
    }
    if (this.options.language !== 'javascript') {
      code = _compileToJS(code, this.options.language);
    }
    if (filename) {
      filename = pa.resolve(filename);
      dirname = pa.dirname(filename);
    } else {
      filename = null;
      dirname = null;
    }
    if (this.running) {
      script = new vm.Script(code, {
        filename: filename != null ? filename : "vm",
        displayErrors: false
      });
      return script.runInContext(this.context, {
        filename: filename != null ? filename : "vm",
        displayErrors: false
      });
    }
    parent = {
      require: require,
      process: process,
      console: console,
      setTimeout: setTimeout,
      setInterval: setInterval,
      setImmediate: setImmediate,
      clearTimeout: clearTimeout,
      clearInterval: clearInterval,
      clearImmediate: clearImmediate
    };
    if (global.DTRACE_HTTP_SERVER_RESPONSE) {
      parent.DTRACE_HTTP_SERVER_RESPONSE = global.DTRACE_HTTP_SERVER_RESPONSE;
      parent.DTRACE_HTTP_SERVER_REQUEST = global.DTRACE_HTTP_SERVER_REQUEST;
      parent.DTRACE_HTTP_CLIENT_RESPONSE = global.DTRACE_HTTP_CLIENT_RESPONSE;
      parent.DTRACE_HTTP_CLIENT_REQUEST = global.DTRACE_HTTP_CLIENT_REQUEST;
      parent.DTRACE_NET_STREAM_END = global.DTRACE_NET_STREAM_END;
      parent.DTRACE_NET_SERVER_CONNECTION = global.DTRACE_NET_SERVER_CONNECTION;
      parent.DTRACE_NET_SOCKET_READ = global.DTRACE_NET_SOCKET_READ;
      parent.DTRACE_NET_SOCKET_WRITE = global.DTRACE_NET_SOCKET_WRITE;
    }
    if (global.COUNTER_NET_SERVER_CONNECTION) {
      parent.COUNTER_NET_SERVER_CONNECTION = global.COUNTER_NET_SERVER_CONNECTION;
      parent.COUNTER_NET_SERVER_CONNECTION_CLOSE = global.COUNTER_NET_SERVER_CONNECTION_CLOSE;
      parent.COUNTER_HTTP_SERVER_REQUEST = global.COUNTER_HTTP_SERVER_REQUEST;
      parent.COUNTER_HTTP_SERVER_RESPONSE = global.COUNTER_HTTP_SERVER_RESPONSE;
      parent.COUNTER_HTTP_CLIENT_REQUEST = global.COUNTER_HTTP_CLIENT_REQUEST;
      parent.COUNTER_HTTP_CLIENT_RESPONSE = global.COUNTER_HTTP_CLIENT_RESPONSE;
    }
    this.context = vm.createContext();
    contextify = vm.runInContext("(function(require) { " + cf + " \n})", this.context, {
      filename: "contextify.js",
      displayErrors: false
    }).call(this.context, require);
    closure = vm.runInContext("(function (vm, parent, contextify, __dirname, __filename) { " + sb + " \n})", this.context, {
      filename: "sandbox.js",
      displayErrors: false
    });
    ref = closure.call(this.context, this, parent, contextify, dirname, filename), this.cache = ref.cache, this.module = ref.module, this.proxy = ref.proxy;
    this.cache[filename] = this.module;
    if (this.options.sandbox) {
      if (typeof this.options.sandbox !== 'object') {
        throw new VMError("Sandbox must be object");
      }
      ref1 = this.options.sandbox;
      for (name in ref1) {
        value = ref1[name];
        contextify(_prepareContextify(value), name);
      }
    }
    this.running = true;
    script = new vm.Script("(function (exports, require, module, __filename, __dirname) { " + code + " \n})", {
      filename: filename != null ? filename : "vm",
      displayErrors: false
    });
    closure = script.runInContext(this.context, {
      filename: filename != null ? filename : "vm",
      displayErrors: false
    });
    closure.call(this.context, this.module.exports, this.module.require, this.module, filename, dirname);
    return this.module.exports;
  };


  /*
  	Create NodeVM and run code inside it.
  	
  	@param {String} script Javascript code.
  	@param {String} [filename] File name (used in stack traces only).
  	@param {Object} [options] VM options.
  	@return {NodeVM} VM.
   */

  NodeVM.code = function(script, filename, options) {
    var _vm;
    if (filename != null) {
      if (typeof filename === 'object') {
        options = filename;
        filename = null;
      } else if (typeof filename === 'string') {
        filename = pa.resolve(filename);
      } else {
        console.log(arguments);
        throw new VMError("Invalid arguments");
      }
    }
    if (arguments.length > 3) {
      throw new VMError("Invalid number of arguments");
    }
    _vm = new NodeVM(options);
    _vm.run(script, filename);
    return _vm;
  };


  /*
  	Create NodeVM and run script from file inside it.
  	
  	@param {String} [filename] File name (used in stack traces only).
  	@param {Object} [options] VM options.
  	@return {NodeVM} VM.
   */

  NodeVM.file = function(filename, options) {
    var _vm;
    _vm = new NodeVM(options);
    filename = pa.resolve(filename);
    if (!fs.existsSync(filename)) {
      throw new VMError("Script '" + filename + "' not found");
    }
    if (fs.statSync(filename).isDirectory()) {
      throw new VMError("Script must be file, got directory");
    }
    _vm.run(fs.readFileSync(filename, 'utf8'), filename);
    return _vm;
  };

  return NodeVM;

})(VM);


/*
VMError.

@param {String} message Error message.

@class
@extends {Error}
@property {String} stack Call stack.
@property {String} message Error message.
 */

VMError = (function(superClass) {
  extend(VMError, superClass);

  function VMError(message) {
    this.name = this.constructor.name;
    this.message = message;
    VMError.__super__.constructor.call(this);
    Error.captureStackTrace(this, this.constructor);
  }

  return VMError;

})(Error);

module.exports.VM = VM;

module.exports.NodeVM = NodeVM;

module.exports.VMError = VMError;
